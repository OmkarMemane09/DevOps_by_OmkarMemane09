#  Terraform Fundamentals
---
<img width="893" height="345" alt="image" src="https://github.com/user-attachments/assets/5a3df7bc-1301-41b5-8732-2bf17673ed12" />


##  What is Terraform?
Terraform is an **open-source Infrastructure as Code (IaC) tool** developed by HashiCorp.  
It allows you to **define, provision, and manage infrastructure** across multiple cloud providers using a **declarative language** called **HCL (HashiCorp Configuration Language)**.

---

##  Why Terraform?
- Multi-Cloud Support (AWS, Azure, GCP, Kubernetes, etc.)
- Declarative IaC ‚Äî define *what* you want, Terraform handles *how* to build it
- Automates infrastructure provisioning
- Enables version-controlled infrastructure using Git
- Provides reusable modules
- Maintains state to track infra changes
- Offers change-preview with `terraform plan`

---
## Diffrenece between Tearraform and cloudformation

| Category | Terraform | CloudFormation |
|----------|-----------|----------------|
| Cloud Support | Multi-cloud | AWS-only |
| Language | HCL | YAML/JSON |
| State | Uses `.tfstate` | Managed by AWS |
| Reusability | Modules | Nested Stacks |
| Rollbacks | Manual | Automatic |
| Provider Support | 100+ providers | Only AWS |
| Learning Curve | Easier | Medium |
| Ideal For | Multi-cloud, DevOps automation | Pure AWS environments |

---

##  When to Use What?

### **Use Terraform When:**
- You want **multi-cloud** deployments  
- You want more **flexibility**  
- You need **modular, reusable infra**  
- You manage **infrastructure outside AWS**  
- You want GitHub, Kubernetes, Azure, GCP integration  

---

### **Use CloudFormation When:**
- You work **only on AWS**  
- You want **deep AWS integration**  
- You need **automatic AWS rollbacks**  
- You don‚Äôt want to manage state files  
- You want AWS-native stack management  

---
##  How Terraform Works 

<img width="818" height="415" alt="image" src="https://github.com/user-attachments/assets/a0cc8e81-6937-4ce0-a0ee-6a3447633328" />


Write .tf file ‚Üí terraform init ‚Üí terraform plan ‚Üí terraform apply ‚Üí terraform destroy


**1. Write** ‚Äî Define resources using HCL  
**2. Init** ‚Äî Downloads provider plugins  
**3. Plan** ‚Äî Shows execution plan  
**4. Apply** ‚Äî Creates or updates infrastructure  
**5. Destroy** ‚Äî Removes infrastructure

---

##  Terraform Language Basics

### üîπ 1. Blocks  
Main building units of Terraform.

Examples: `provider`, `resource`, `variable`, `output`, `module`.

Example block:
```hcl
resource "aws_instance" "myEC2" {
  ami           = "ami-123456"
  instance_type = "t2.micro"
}
```
### üîπ 2. Arguments
Key-value pairs inside blocks.

```hcl
instance_type = "t2.micro"
```
### üîπ 3. Expressions
Dynamic value references.
```hcl
var.instance_type
aws_vpc.main.id
```

## Terraform Core Components
### 1Ô∏è. Provider
Specifies which **cloud/platform** Terraform will use.

```hcl
provider "aws" {
  region = "ap-south-1"
}
```
### 2Ô∏è. Resource
Actual infrastructure objects.
```hcl
resource "aws_s3_bucket" "myBucket" {
  bucket = "my-demo-bucket"
}
```
### 3Ô∏è. Variables
For **reusability** and dynamic values.

```hcl
variable "instance_type" {
  type = string
}
```
### 4Ô∏è. Outputs
Display useful results after provisioning.

```hcl
output "public_ip" {
  value = aws_instance.myEC2.public_ip
}
```
### 5Ô∏è. Modules
Reusable Terraform configurations.

```hcl
module "vpc" {
  source = "./modules/vpc"
}
```
##  Terraform State (terraform.tfstate)
Terraform tracks infrastructure using a state file.

#### Why is **State Important**?
- Maps real cloud resources to Terraform configs

- Tracks metadata & changes

- Prevents accidental recreation

- Enables collaboration

**State Storage Options:**
- Local state (default)

- Remote state backends:

 - AWS S3 (with DynamoDB locking)

 - Terraform Cloud

 - Consul

 - GCS

### Advantages of Terraform
 - Multi-Cloud	Works across AWS, Azure, GCP, Kubernetes
 - Declarative	Only specify desired state
 - Modular	Reusable modules
 - Idempotent	Running code twice gives same result
 - Dependency Handling	Auto resolves resource creation order
 - Version Control	.tf files stored in GitHub
 - Predictable	terraform plan shows upcoming changes

### Disadvantages of Terraform
 - Limitation	Explanation
 - Learning Curve	Concepts like IaC, state, lifecycle
 - State Risks	Can store sensitive data
 - Provider Limitations	Not always updated instantly
 - Collaboration Issues	Requires remote state + locking

## HCL (HashiCorp Configuration Language) 
**HCL Features:**
 - Human-readable

 - JSON-compatible

 - Supports comments

```hcl
# This is a comment
```

**Data Types**
```
- string

- number

- bool

- list

- map

- object
```
Example:

```hcl
variable "tags" {
  type = map(string)
}
```
### Terraform Workflow Commands
```hcl
terraform init       # Initialize provider plugins
terraform validate   # Validate configuration
terraform fmt        # Format .tf files
terraform plan       # Preview infra changes
terraform apply      # Create/update infra
terraform destroy    # Delete infra
terraform show       # Show state info
terraform providers  # List providers
```
---

### Terraform Set-Up for aws EC2

#### Step 1. Install AWS-CLI
```bash
sudo apt update
```
```bash
snap install aws-cli --classic
```
```bash
aws configure
```
#### Step 2. Terraform Installation Commands
```bash
wget -O - https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(grep -oP '(?<=UBUNTU_CODENAME=).*' /etc/os-release || lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt update && sudo apt install terraform
```
#### Make File 
```bash
nano main.tf
```
**main.tf Script**

```hcl
provider "aws" {
  region = "ap-south-1"
}

resource "aws_instance" "myEC2" {
  ami           = "ami-123456"
  instance_type = "t2.micro"
  tags = {
    Name = "Terraform-EC2"
  }
}
```
```bash
terraform init
```
```bash
terraform plan
```
```bash
terraform apply --auto-approve
```


