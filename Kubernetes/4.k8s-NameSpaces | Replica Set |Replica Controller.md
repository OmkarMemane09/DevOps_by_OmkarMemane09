# üè∑Ô∏èKubernetes Namespaces Explained
Namespaces in Kubernetes are a powerful feature that help you organize, isolate, and manage resources within a cluster. They create logical partitions, allowing multiple teams, environments, or projects to share a cluster without interfering with each other.

---

### What is a Namespace in Kubernetes?

- A **namespace** is a virtual sub-cluster inside a Kubernetes cluster.
- It provides **scope for names**: resources in different namespaces can have the same name.
- Designed for **multi-tenant environments**, separating workloads and teams.
- Useful for separating environments (dev, test, prod), teams, or even applications.

---

### Why Use Namespaces?

- **Organization:** Cleanly group resources for different teams or projects.
- **Isolation:** Prevent unwanted interaction or access between teams/applications.
- **Access Control:** Apply fine-grained RBAC (Role-Based Access Control) at the namespace level.
- **Resource Quotas:** Enforce memory/CPU limits to avoid resource hogging by one group.

---

### Default Namespaces in Kubernetes

When a cluster is created, these namespaces exist by default:

| Namespace         | Purpose                                                                    |
|-------------------|----------------------------------------------------------------------------|
| `default`         | Where user workloads go unless a namespace is specified                    |
| `kube-system`     | Hosts system pods and Kubernetes components (DNS, dashboard, etc.)         |
| `kube-public`     | Can be read by all users; used for cluster-wide public data                |
| `kube-node-lease` | Tracks node heartbeats for fast node failure detection                     |

---

### How to Work With Namespaces

#### Listing Namespaces
```bash
kubectl get namespaces
```

#### Creating a Namespace (kubectl)
```bash
kubectl create namespace my-namespace
```

#### Creating a Namespace (YAML)
```bash
apiVersion: v1
kind: Namespace
metadata:
  name: my-namespace

```
#### Apply this file
```bash
kubectl apply -f namespace.yaml
```

#### Setting Namespace Context
```bash
kubectl config set-context --current --namespace=my-namespace

```

#### Using Namespaces in Manifests

Most resource manifests can specify which namespace they belong to:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: sample-pod
  namespace: my-namespace
spec:
  containers:
  - name: nginx
    image: nginx
```
---

### Workflow

1. Create a namespace for your project:
   ```bash
    kubectl create namespace blog-app
    ```
3. Deploy resources (Pods, Services, Deployments) to that namespace:
    ```bash
    kubectl apply -f deployment.yaml -n blog-app
    ```
4. List resources in your namespace:
    ```bash
    kubectl get all -n blog-app
    ```

---
# Kubernetes ReplicaSet & ReplicationController:

Both **ReplicaSet** and **ReplicationController** are Kubernetes controllers that ensure a specified number of identical Pods are running at any given time. They provide powerful self-healing and scaling features, but ReplicaSet is the newer and recommended controller.

---

## üóÑÔ∏è ReplicationController

- The original controller to manage pod replicas in Kubernetes.
- Ensures a fixed number of pods are running‚Äîif any pod crashes or is deleted, it starts a replacement.
- **Selectors:** Only supports *equality-based* selectors (`key = value`) for matching pods.
- **API Version:** `apiVersion: v1` (legacy).

### Example: ReplicationController YAML

```yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: nginx-rc
spec:
  replicas: 3
  selector:
    app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx
          ports:
            - containerPort: 80

```

### Basic Hands-on Commands
```bash
kubectl create -f nginx-rc.yaml
```
```bash
kubectl get rc
```
```bash
kubectl get pods
```
```bash
kubectl describe rc nginx-rc
```
```bash
kubectl scale --replicas=5 rc/nginx-rc # Scale up/down
```
```bash
kubectl delete pod <pod-name> # RC recreates the pod!
```
```bash
kubectl delete rc nginx-rc # Delete RC and its pods
```
---

## üÜï ReplicaSet

- Successor to the ReplicationController; recommended for all new workloads[web:153][web:162][web:154].
- Ensures a set number of pods are running at all times; replaces any that fail.
- **Selectors:** Supports *set-based* selectors, adding more flexibility (e.g., `key in (value1, value2)`).
- **API Version:** `apps/v1` (modern standard).
- Usually managed by Deployments for rolling updates and rollbacks.

### Example: ReplicaSet YAML
```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: nginx-rs
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx
          ports:
            - containerPort: 80

```

### Hands-on Practice
```bash
kubectl apply -f nginx-rs.yaml
```
```bash
kubectl get rs
```
```bash
kubectl get pods
```
```bash
kubectl describe rs nginx-rs
```
```bash
kubectl scale --replicas=5 rs/nginx-rs # Scale up/down
```
```bash
kubectl delete pod <pod-name> # RS recreates the pod!
```
```bash
kubectl delete rs nginx-rs # Delete RS and its pods
```
---

## üí° Key Differences Table

| Feature                | ReplicationController        | ReplicaSet                     |
|------------------------|-----------------------------|--------------------------------|
| API Version            | v1                          | apps/v1                        |
| Label Selector Support | Equality-based only          | Set-based & equality-based     |
| Typical Usage          | Legacy systems               | Modern; most used with Deployments  |
| Rolling Updates        | ‚ùå (no native support)        | ‚ùå (used by Deployments for rollouts) |
| Self-Healing           | ‚úÖ                           | ‚úÖ                             |
| Scaling                | ‚úÖ                           | ‚úÖ                             |

---

## Quick Replay

- **Prefer ReplicaSet (or Deployment) over ReplicationController** for all new apps.
- Use **Deployments** (which use ReplicaSets internally) for advanced features: rolling updates, rollbacks, version control.
- Use selectors and labels wisely for organizing pod groups.
- Practice scaling and self-healing by deleting pods and watching controllers re-create them automatically.

---

## üì¶ Workflow

1. **Write YAML spec (above)**
2. **Apply with:** `kubectl apply -f <filename>.yaml`
3. **Check resources:** `kubectl get rs` / `kubectl get pods`
4. **Scale:** `kubectl scale --replicas=N rs/<name>`
5. **Delete Pods (to test self-healing):** `kubectl delete pod <name>`
6. **Delete ReplicaSet:** `kubectl delete rs <name>`

---
