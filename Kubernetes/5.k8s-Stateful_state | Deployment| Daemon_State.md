#  Deployments , StatefulSets & DaemonSets

##  Introduction
Kubernetes uses **controllers** to automate and manage the desired state of your workloads. The most common controllers—**Deployments**, **StatefulSets**, and **DaemonSets**—each solve different challenges for running modern applications at scale. Here's how they work, when to use them, and how to write their manifests.

---

##  Deployments vs StatefulSets

###  Deployments

A **Deployment** ensures a desired number of interchangeable Pod replicas are available at any given time, making them ideal for stateless applications.

#### Features of Deployments
- **Stateless**: All pods are identical and interchangeable.
- **Rolling Updates**: Supports zero-downtime deployments.
- **Fast Rollback**: Instantly revert to previous versions.
- **Simple Scaling**: Add or remove any number of replicas at once.
- **Pod Identity**: Pods have random names and are replaced freely.

#### Use Cases
- Web servers (e.g., Nginx, Apache)
- REST APIs and backend services
- Any stateless microservice

---

###  StatefulSets

A **StatefulSet** manages Pods with **unique identities** and is designed for stateful applications requiring stable storage.

#### Features of StatefulSets
- **Stable, Unique Pod Identity**: Pod names follow a predictable, ordered pattern (`myapp-0`, `myapp-1`, ...).
- **Persistent Storage**: Each Pod gets its own PersistentVolumeClaim (PVC), keeping data even when the Pod restarts.
- **Ordered, Controlled Scaling/Updates**: Pods are created or updated one-by-one in order.
- **Sticky Network Identity**: Each Pod gets a stable DNS name using a headless Service.

#### Use Cases
- Databases (MySQL, MongoDB, PostgreSQL)
- Distributed systems (Kafka, Zookeeper, Cassandra)
- Stateful microservices

---

###  Key Differences: Deployment vs. StatefulSet

| Feature                | Deployment                    | StatefulSet                        |
|------------------------|-------------------------------|------------------------------------|
| Pod Nature             | Stateless (Interchangeable)   | Stateful (Unique/Sticky identity)  |
| Pod Identity           | Random, non-persistent        | Stable, sequential, persistent     |
| Persistent Storage     | Shared/Ephemeral Volumes      | Dedicated PVC per Pod              |
| Scaling Behavior       | Parallel, unordered           | Ordered, controlled                |
| Update Strategy        | Rolling updates, rollback     | Ordered, controlled updates        |
| Network Identity       | Dynamic                       | Stable via Headless Service        |

---

##  Stateless vs  Stateful Applications

### Stateless Applications
- **No session/data is stored on the Pod itself.**
- Pods can be killed and replaced at any time, with zero impact on users.
- Example: Web server serving static pages.

### Stateful Applications
- **Session, identity, or data must be preserved.**
- Each Pod needs persistent volume and/or stable DNS/network name.
- Replacement Pod must mount same storage to preserve data.
- Example: PostgreSQL database, Kafka broker.

---
---
### Workflow

1. **Write/Edit Manifest:**  
   ```bash
   nano deployment.yaml
   ```

2. **Apply Manifest:**
   ```bash
   kubectl apply -f deployment.yaml
   ```

3. **Check:**
   ```bash
     kubectl get deployments
   ```

4. **Clean up:**  
   ```bash
   kubectl delete -f deployment.yaml
   ```

### Manifest for a Deployment
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
  labels:
    app: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: nginx
          image: nginx:latest
          ports:
            - containerPort: 80

```
---

### Manifest for a StatefulSet
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata: 
    name: my-sts
spec:
  selector: 
    matchLabels: 
        app: my-app
  serviceName: "my-sts-service"
  replicas: 3
  template:
    metadata:
      labels:
        app: my-app
    spec:
        containers:
           - name: mysql
             image: mysql:latest
             env:
              - name: MYSQL_ROOT_PASSWORD    
                value: redhat
             ports:
                - containerPort: 3306
```
**Note:** StatefulSet usually requires a headless Service (with `clusterIP: None`) for stable DNS.

---

## Deployment Strategies

- **Recreate:** Terminates all old Pods before creating new ones (potential downtime).
- **Rolling Update:** Updates Pods incrementally for minimal downtime (most common).
- **Canary Deployment:** Deploy a small subset of new Pods to test before full rollout.
- **Blue-Green Deployment:** Deploy a parallel set of Pods and switch traffic after verification.

---

##  Understanding DaemonSets

A **DaemonSet** ensures a copy of a specific Pod runs **on every (or selected) node** in the cluster. Used mostly for system tools — not user-facing apps.

### Features of DaemonSets
- **One Pod per Node**: Runs everywhere in the cluster.
- **Auto-Scheduling**: New Pods created on newly joined nodes.
- **Great for System Tools**: Logging, monitoring, networking.

### Use Cases
- **Log collection**: e.g., fluentd, logstash.
- **Monitoring agents**: e.g., Prometheus node-exporter.
- **Network plugins**: e.g., Calico, WeaveNet.

---

### Manifest for a DaemonSet
```yaml

apiVersion: apps/v1
kind: DaemonSet
metadata: 
    name: my-dmnset
spec: 
    selector:
      matchLabels:
          app: fluentd
    template:
      metadata:
        labels:
          app: fluentd
      spec:
        nodeSelector:
            hostname: node01
        containers:
          - name: fluentd
            image: fluentd:latest
            ports:
              - containerPort: 24224
```
---
## Quick Revise
- **Use Deployments for stateless, scalable apps.**
- **Use StatefulSets for databases or apps needing persistent identity/volumes.**
- **Use DaemonSets for system-wide operations (logging, monitoring agents).**
- Always specify correct selectors/labels in manifests.
- For stateful workloads, include `volumeClaimTemplates` for PVCs.
- Use headless Services (`clusterIP: None`) with StatefulSets for stable DNS resolution.
- Use Deployment strategies based on the update/availability needs.

---
